/*description:
{
	It takes in charge of translating any \CodeWorker\ script to HTML.

	The source file is highlighted and keywords plus particular symbols of the
	language are linked to the online-documentation.

	Note that \samp{this.docURL} designates the URL or the directory where both the CSS
	and the	HTML documentation of \CodeWorker\ are stored. If not populated, it will resolve
	links from the directory where is the target HTML file. Don't forget to end the URL or
	directory with a trailing slash.

	To highlight any script, type:\\
	\texttt{CodeWorker \textbf{-translate} CWscript2HTML.cws \textit{<CW-script.cw>} \textit{<CW-script.html>}}\\
	to consider that the documentation and the CSS are in the same directory, and:\\
	\texttt{CodeWorker \textbf{-translate} CWscript2HTML.cws \textit{<CW-script.cw>} \textit{<CW-script.html>} \textbf{-insert} docURL \textit{HTML-doc-URL}}\\
	otherwise.
}
*/

#include "CodeWorker_grammar.cwp"

#overload #ignore	::=
		[
				' ' | '\t' | '\r' | '\n'
			|
				"/*"
				=> insertText($getOutputLocation() - 2$, "<span class=\"comment\">");
				ignoreEmbeddedComment
				=> {@</span>@}
			|
				"//"
				=> insertText($getOutputLocation() - 2$, "<span class=\"comment\">");
				[~[['\r']? '\n']]*
				#explicitCopy
				['\r']? '\n'
				=> {@</span><br/>
		@}
		]*;

function transformChar(cChar : value) {
	if cChar == ' ' return "&nbsp;";
	if cChar == '\t' return "&nbsp;&nbsp;&nbsp;&nbsp;";
	if cChar == '\n' return "<br/>" + endl();
	if cChar != '\r' return composeHTMLLikeString(cChar);
}

#implicitCopy(transformChar)

#overload translation_unit	::=
		=> {@<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html>
	<head>
		<link rel="stylesheet" type="text/css" href="@this.docURL@CodeWorker.css" />
	</head>
	<body class="script">
		@}
		script<this>
		=> {@<hr />
		Generated by <I class="CodeWorker">CodeWorker</I> v@getVersion()@ from <a href="@this.docURL@CWscript2HTML.html">CWscript2HTML.cws</a>.
	</body>
</html>
@}
		;

#overload script<"template-based">	::=
		#continue
		[
			=> {@<span class="raw_text">@}
			->['@' | "<%"]
			=> {@</span>@}
			#continue
			#ignore
			[
					expression
					=> {@<span class="raw_text">@}
					['@' | "%>" | #empty]
				|
					[instruction]*
					=> {@<span class="raw_text">@}
					['@' | "%>" | #empty]
			]
			=> {@</span>@}
		]+
		=> {@</span>@}
		;

#overload instruction	::=
		'{' #continue [instruction]* '}'
	|
		#readIdentifier:sKeyword
		=> local iLocation = getOutputLocation();
		[
				instruction<sKeyword>
				=> insertText(iLocation, "</A>");
				=> insertText($iLocation - sKeyword.length()$, "<A class=\"instruction\" href=\"" + this.docURL + "manual_The_scripting_language.html#" + sKeyword + "\">");
			|
				predefined_function_call<sKeyword> ';'
				=> insertText(iLocation, "</A>");
				=> insertText($iLocation - sKeyword.length()$, "<A class=\"function\" href=\"" + this.docURL + "manual_The_scripting_language.html#" + sKeyword + "\">");
			|
				predefined_procedure_call<sKeyword> ';'
				=> insertText(iLocation, "</A>");
				=> insertText($iLocation - sKeyword.length()$, "<A class=\"procedure\" href=\"" + this.docURL + "manual_The_scripting_language.html#" + sKeyword + "\">");
			|
				user_function_call ';'
		]
	|
		=> local iLocation = getOutputLocation();
		'#'
		#readIdentifier:sKeyword
		=> insertText(iLocation, "<a class=\"directive\" href=\"" + this.docURL + "manual_The_scripting_language.html#_" + sKeyword + "\">");
		=> {@</a>@}
		preprocessor<sKeyword>
	|
		#check(this != "procedural")
		=> {@<span class="raw_text">@}
		['@' | "%>"]
		#!ignore
		#continue ->['@' | "<%" | #empty]
		=>{@</span>@}
		#ignore
		[expression ![!'@' !"%>" !#empty]]?
		;

#overload literal_expression<bNumeric>	::=
		=> local iLocation = getOutputLocation();
		[
				CONSTANT_STRING
			|
				'(' #continue expression<bNumeric> ')'
			|
				'$'
				=> insertText(iLocation, "<a class=\"constant\" href=\"" + this.docURL + "manual_The_scripting_language.html#$\">");
				=> {@</a>@}
				#continue #check(!bNumeric) expression<true>
				=> {@<a class="constant" href="@this.docURL@manual_The_scripting_language.html#$">@}
				'$'
				=> {@</a>@}
			|
				'~'
				=> insertText(iLocation, "<a class=\"constant\" href=\"" + this.docURL + "manual_The_scripting_language.html#numeric_expression\">");
				=> {@</a>@}
				#continue #check(bNumeric) literal_expression<true>
			|
				CONSTANT_CHAR
			|
				'!'
				=> insertText(iLocation, "<a class=\"constant\" href=\"" + this.docURL + "manual_The_scripting_language.html#boolean_expression\">");
				=> {@</a>@}
				#continue literal_expression<bNumeric>
			|
				#readNumeric
				=> insertText(iLocation, "<span class=\"numeric\">");
				=> {@</span>@}
			|
				#readIdentifier:{"true", "false"}
				=> insertText(iLocation, "<a class=\"constant\" href=\"" + this.docURL + "manual_The_scripting_language.html#boolean_literals\">");
				=> {@</a>@}
			|
				function_call
			|
				variable_expression ['.' #continue method_call]?
		]
		;

#overload function_call	::=
		#readIdentifier:sFunctionName
		=> local iLocation = getOutputLocation();
		[
				predefined_function_call<sFunctionName>
				=> insertText(iLocation, "</A>");
				=> insertText($iLocation - sFunctionName.length()$, "<A class=\"function\" href=\"" + this.docURL + "manual_The_scripting_language.html#" + sFunctionName + "\">");
			|
				user_function_call
		];

#overload method_call	::=
		#readIdentifier:sMethodName
		=> local iLocation = getOutputLocation();
		[
				predefined_method_call<sMethodName>:sFunctionName
				=> insertText(iLocation, "</A>");
				=> insertText($iLocation - sMethodName.length()$, "<A class=\"function\" href=\"" + this.docURL + "manual_The_scripting_language.html#" + sFunctionName + "\">");
			|
				user_method_call<sMethodName>
		];

#overload variable_expression<sIdentifier> : #!ignore	::=
		=> if sIdentifier == "project" || sIdentifier == "this" {
			insertText($getOutputLocation() - sIdentifier.length()$, "<a class = \"constant\" href=\"" + this.docURL + "manual_The_scripting_language.html#" + sIdentifier + "\">");
			@</a>@
		}
		#super::variable_expression<sIdentifier>
		;


#overload DEFAULT	::=
		=> {@<B>@}
		#readIdentifier:"default"
		=> {@</B>@};

#overload CASE	::=
		=> {@<B>@}
		#readIdentifier:"case"
		=> {@</B>@};

#overload START	::=
		=> {@<B>@}
		#readIdentifier:"start"
		=> {@</B>@};

#overload CASCADING	::=
		=> {@<B>@}
		#readIdentifier:"cascading"
		=> {@</B>@};

#overload ELSE	::=
		=> {@<B>@}
		#readIdentifier:"else"
		=> {@</B>@};

#overload IN		::=
		=> {@<B>@}
		#readIdentifier:"in"
		=> {@</B>@};

#overload NO_CASE	::=
		=> {@<B>@}
		#readIdentifier:"no_case"
		=> {@</B>@};

#overload SORTED	::=
		=> {@<B>@}
		#readIdentifier:"sorted"
		=> {@</B>@};

#overload WHILE	::=
		=> {@<B>@}
		#readIdentifier:"while"
		=> {@</B>@};

#overload CONSTANT_STRING	::=
		=> local iLocation = getOutputLocation();
		#readCString
		=> insertText(iLocation, "<span class=\"string\">");
		=> {@</span>@}
		;

#overload CONSTANT_CHAR	::=
		=> local iLocation = getOutputLocation();
		'\'' #!ignore #continue ['\\']? #readChar '\''
		=> insertText(iLocation, "<span class=\"string\">");
		=> {@</span>@}
		;

#overload PRULE_SYMBOL	::=
		=> {@<a class="constant" href="@this.docURL@manual_The_scripting_language.html#parsing_BNF_syntax">@}
		"::="
		=> {@</a>@}
		;

#overload NON_TERMINAL	::=
		=> {@<i>@}
		#readIdentifier
		=> {@</i>@}
		;

#overload ALTERNATION	::=
		=> local iLocation = getOutputLocation();
		'|'
		=> insertText(iLocation, "<a class=\"instruction\" href=\"" + this.docURL + "manual_The_scripting_language.html#parsing_alternation\">");
		=> {@</a>@}
		;

#overload TR_BEGIN		::=
		=> local iLocation = getOutputLocation();
		'<'
		=> insertText(iLocation, "<a class=\"instruction\" href=\"" + this.docURL + "manual_The_scripting_language.html#BNF_declaring_a_clause\">");
		=> {@</a>@}
		;

#overload TR_END		::=
		=> local iLocation = getOutputLocation();
		'>'
		=> insertText(iLocation, "<a class=\"instruction\" href=\"" + this.docURL + "manual_The_scripting_language.html#BNF_declaring_a_clause\">");
		=> {@</a>@}
		;


#overload BNF_general_directive	::=
		=> local iLocation = getOutputLocation();
		'#'
		#readIdentifier:sKeyword
		=> insertText(iLocation, "<a class=\"directive\" href=\"" + this.docURL + "manual_The_scripting_language.html#_" + sKeyword + "\">");
		=> {@</a>@}
		BNF_general_directive<sKeyword>
		;

#overload BNF_general_directive<"overload">	::=
		'#'
		=> insertText($getOutputLocation() - 1$, "<a class=\"directive\" href=\"" + this.docURL + "manual_The_scripting_language.html#_ignore\">");
		#continue #readIdentifier:"ignore"
		=> {@</a>@}
		BNF_general_directive<"ignore">
	|
		production_rule;

#overload BNF_catch	::=
		'#'
		=> insertText($getOutputLocation() - 1$, "<a class=\"directive\" href=\"" + this.docURL + "manual_The_scripting_language.html#_try\">");
		#continue
		"catch"
		=> {@</a>@}
		'(' variable_expression ')';

#overload BNF_clause_preprocessing	::=
		':' '#'
		=> insertText($getOutputLocation() - 1$, "<a class=\"directive\" href=\"" + this.docURL + "manual_The_scripting_language.html#BNF_preprocessing_of_a_clause\">");
		#continue
		[
				'!'
				#continue
				#readIdentifier:"ignore"
			|
				#readIdentifier:"ignore"
		]
		=> {@</a>@};

#overload BNF_literal<bTokenCondition>	::=
		CONSTANT_STRING
		[#check(bTokenCondition) ':' #continue variable_expression]?
	|
		CONSTANT_CHAR
		[
				".." #continue CONSTANT_CHAR
				[#check(bTokenCondition) BNF_token_post_processing]?
			|
				[#check(bTokenCondition) ':' #continue variable_expression]?
		]
	|
		[
				'~'
				=> insertText($getOutputLocation() - 1$, "<a class=\"instruction\" href=\"" + this.docURL + "manual_The_scripting_language.html#BNF_token_complementary\">");
				=> {@</a>@}
			|
				'^'
				=> insertText($getOutputLocation() - 1$, "<a class=\"instruction\" href=\"" + this.docURL + "manual_The_scripting_language.html#BNF_token_complementary\">");
				=> {@</a>@}
			|
				'!'
				=> insertText($getOutputLocation() - 1$, "<a class=\"instruction\" href=\"" + this.docURL + "manual_The_scripting_language.html#BNF_token_negation\">");
				=> {@</a>@}
			|
				"->"
				=> insertText($getOutputLocation() - 10$, "<a class=\"instruction\" href=\"" + this.docURL + "manual_The_scripting_language.html#-_amp_gt_\">");
				=> {@</a>@}
		]
		#continue BNF_literal<false>
		[#check(bTokenCondition) BNF_token_post_processing]?
	|
		'['
		=> insertText($getOutputLocation() - 1$, "<a class=\"instruction\" href=\"" + this.docURL + "manual_The_scripting_language.html#BNF_token_repeating_a_token\">");
		=> {@</a>@}
		#continue BNF_sequence [ALTERNATION #continue BNF_sequence]*
		=> {@<a class="instruction" href="@this.docURL@manual_The_scripting_language.html#BNF_token_repeating_a_token">@}
		']'
		[
			'?' | '+' | '*' | #readInteger
			[".." #continue [#readInteger | '*']]?
		]?
		=> {@</a>@}
		[#check(bTokenCondition) BNF_token_post_processing]?
	|
		'#'
		=> local iLocation = $getOutputLocation() - 1$;
		#continue
		[
				'!'
				#continue
				#readIdentifier:"ignore"
				=> insertText(iLocation, "<a class=\"directive\" href=\"" + this.docURL + "manual_The_scripting_language.html#_ignore\">");
				=> {@</a>@}
			|
				#readIdentifier:sDirective
				=> insertText(iLocation, "<a class=\"directive\" href=\"" + this.docURL + "manual_The_scripting_language.html#_" + sDirective + "\">");
				=> {@</a>@}
				BNF_directive<sDirective>:bTokenConditionAllowed
				[
					#check(bTokenCondition && bTokenConditionAllowed)
					BNF_token_post_processing
				]?
		]
	|
		"=>"
		=> insertText($getOutputLocation() - 5$, "<a class=\"instruction\" href=\"" + this.docURL + "manual_The_scripting_language.html#BNF_operator__eq__amp_gt_\">");
		=> {@</a>@}
		#continue instruction
	|
		BNF_clause_call
		[#check(bTokenCondition) BNF_token_post_processing]?
	;

